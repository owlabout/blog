const closeTemplate = {
  type: "block_close",
  tag: "div",
  attrs: null,
  map: null,
  nesting: -1,
  level: 0,
  children: null,
  content: "",
  markup: "",
  info: "",
  meta: null,
  block: true,
  hidden: false
};

// only available in opening tag, so it is cached for closing
let infoCache;

/**
 * On first :::sticky creates
 * <div class="sticky__container">
 *  <div>
 *    <div class="sticky">
 *
 * @param {*} tokens
 * @param {*} idx
 * @param {*} title
 */
function before(tokens, idx, title) {
  /**
   * if not firstSticky close "content part" and close sticky__container
   * before opening a new one
   *  </div>
   * </div>
   */
  const opening = `${
    tokens.firstSticky ? "" : "</div></div>"
  }<div class="sticky__container"><div><div class="sticky">`;
  if (tokens.firstSticky) {
    // save global state
    tokens.firstSticky = false;
    /**
     * push two closing divs to end of content
     * to close "content part" and sticky__container
     *  </div>
     * </div>
     */
    tokens.push(closeTemplate, closeTemplate);
  }
  return opening;
}

/**
 * ::: (closing tag) closes "sticky part" and opens "content part"
 *    </div>
 *  </div>
 *  <div>
 * @param {*} tokens
 * @param {*} idx
 * @param {*} title
 */
function after(tokens, idx, title) {
  return `${title}</div></div><div>`;
}

export default function mdSticky(md, name, opts) {
  md.use(require("markdown-it-container"), "sticky", {
    render(tokens, idx) {
      // dirty hack to save global state per tokenList
      if (typeof tokens.firstSticky === "undefined") {
        tokens.firstSticky = true;
      }
      const info = tokens[idx].info ? tokens[idx].info : infoCache;
      const title = info.replace(/^sticky(.*)$/, `$1`).trim();
      if (tokens[idx].nesting === 1) {
        infoCache = info;
        return before(tokens, idx, title);
      } else {
        return after(tokens, idx, title);
      }
    }
  });
}
